\documentclass[a4paper,12pt]{report}

% https://tex.stackexchange.com/a/63393
\makeatletter
\def\@makechapterhead#1{%
  %%%%\vspace*{50\p@}% %%% removed!
  {\parindent \z@ \raggedright \normalfont
    \ifnum \c@secnumdepth >\m@ne
        \huge\bfseries \@chapapp\space \thechapter
        \par\nobreak
        \vskip 20\p@
    \fi
    \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
\def\@makeschapterhead#1{%
  %%%%%\vspace*{50\p@}% %%% removed!
  {\parindent \z@ \raggedright
    \normalfont
    \interlinepenalty\@M
    \Huge \bfseries  #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother

% spacings
\usepackage[a4paper,right=15mm,left=25mm,top=20mm,bottom=20mm]{geometry}

% 1.5 line spacing
\usepackage{setspace}
\setstretch{1.5}

% Being able to copy-paste from the document
% Display the diacritics correctly
\usepackage{fontspec}
% Times New Roman font
\setmainfont{Times New Roman}

% Romanian language support
\usepackage[romanian]{babel}

% Appendices
\usepackage[toc,page]{appendix}

% Lista abrevierelor
\usepackage[printonlyused]{acronym}

% Format urls in the bibliography
% \usepackage{url}
\usepackage{hyperref}
% Clickable table of contents
\hypersetup{linktoc=all}

% Code blocks
\usepackage{minted}
\setminted{%
  autogobble=true,
  codetagify=true,
  linenos=true,
  breaklines=true,
  baselinestretch=0.8,
  % https://www.giss.nasa.gov/tools/latex/ltx-178.html
  fontsize=\footnotesize
  % Prevent it from spilling over margins for especially long lines
  ,breakanywhere=true
  ,xleftmargin=\parindent
}

% Chapters should count with roman numerals
\renewcommand{\thechapter}{\Roman{chapter}}
\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}}
\renewcommand{\thesubsection}{\arabic{chapter}.\arabic{section}.\arabic{subsection}}

% Add dots to numbers, only applies to TOC
\let\savenumberline=\numberline
\def\numberline#1{\savenumberline{#1.}}

% Chapters must left aligned and 14 pt.
% There's no 14 pt available, though, only 14.4 (\large)
% https://tex.stackexchange.com/questions/24599/what-point-pt-font-size-are-large-etc/24600#24600
\usepackage{titlesec}
% \titleformat{〈command 〉}[〈shape〉]{〈format〉}{〈label 〉}{〈sep〉}{〈before-code〉}[〈after-code〉]
% https://mirror.marwan.ma/ctan/macros/latex/contrib/titlesec/titlesec.pdf#page=4&zoom=200,67,627
% It gets pretty involved...
\def\tabSize{1cm}
\titleformat{\chapter}[block]{\normalfont\large\bfseries\filcenter}{\thechapter.~}{\tabSize}{}
\titleformat{\section}[block]{\normalfont\normalsize\bfseries\filright}{\thesection~}{\tabSize}{}
\titleformat{\subsection}[block]{\normalfont\normalsize\bfseries\filright}{\thesubsection~}{\tabSize}{}

% Skips before and after the title
\titlespacing*{\chapter}{0pt}{12pt}{6pt}
\titlespacing*{\section}{0pt}{12pt}{6pt}
\titlespacing*{\subsection}{0pt}{12pt}{6pt}

% Aliniat de 1 cm.
\usepackage{indentfirst}
\setlength{\parindent}{1.0cm}

% https://tex.stackexchange.com/questions/163451/total-number-of-citations
\usepackage{totcount}
\newtotcounter{citnum} % From the package documentation
\def\oldbibitem{} \let\oldbibitem=\bibitem{}
\def\bibitem{\stepcounter{citnum}\oldbibitem}

\newtotcounter{num_chapters}
\def\oldchapter{} \let\oldchapter=\chapter{}
\def\chapter{\stepcounter{num_chapters}\oldchapter}

% Thank you to @paante on LaTeX Discord.
% Makes it possible to mark pages and then do math on them.
% usage: \markpage{key}
%        \getpagemark{key}
\newwrite\pagecountf
\AtBeginDocument{%
    \InputIfFileExists{\jobname.pagecount}{}{}%
    \immediate\openout\pagecountf={\jobname.pagecount}%
}
\AtEndDocument{\closeout\pagecountf}
\protected\def\markpage#1{%
    \write\pagecountf{%
        \noexpand\expandafter\gdef
            \noexpand\csname pagecount/#1\endcsname
            {\the\value{page}}%
    }%
}
\def\getpagemark#1{\ifcsname pagecount/#1\endcsname \csname pagecount/#1\endcsname \else 0\fi}


% Extracting the name of chapters.
% https://tex.stackexchange.com/questions/62241/how-to-get-the-current-chapter-name-section-name-subsection-name-etc
\usepackage{nameref}

% No spacing for lists.
% https://tex.stackexchange.com/questions/10684/vertical-space-in-lists
\usepackage{enumitem}
\setlist{nosep}


\newcommand{\unnumberedChapter}[1]{%
  \chapter*{#1}
  \addcontentsline{toc}{chapter}{#1}}

% SIGN HERE: _______ sort of field
\def\underscores#1{\leavevmode \leaders\hrule\hskip#1\relax}

% Description
\newcommand{\authorName}{CURMANSCHII Anton}
\newcommand{\thesisTitle}{Generarea codului în dezvoltarea jocurilor pe calculator}
\newcommand{\uniGroupName}{IA1901}
\newcommand{\programulDeStudii}{licență}
\newcommand{\identificatorulCursului}{0613.5 Informatică aplicată}

% does math on counters
\newcommand{\usefulPageCount}{%
  % this evaluates a math expression, which is `end - begin`
  \the\numexpr\getpagemark{usefulStuffEnd}-\getpagemark{usefulStuffBegin}\relax}

\newcommand{\anexeCount}{20} % for now, hardcode this
\newcommand{\conferencesList}{I don't know what to write here}
\newcommand{\bibliographyEntryCount}{\total{citnum}}
\newcommand\chapterConclusionSection[1]{\section{Concluziile la capitol \arabic{chapter}}}

% Start
\begin{document}

% Prevent spills over margin
\sloppy

\begin{titlepage}
  \vspace*{\fill}
  \begin{center}
      \vspace*{1cm}

      \large
      \uppercase{\textbf{UNIVERSITATEA DE STAT DIN MOLDOVA\\}}

      \normalsize
      \uppercase{\textbf{FACULTATEA DE MATEMATICĂ și INFORMATICĂ}}
      \vspace{0.1cm}

      \normalsize
      \uppercase{\textbf{SPECIALITATEA INFORMATICA APLICATĂ}}
      \vspace{3.0cm}

      \large
      \textbf{\expandafter{\authorName}}
      \vspace{1.5cm}

      \Large
      \textbf{\uppercase\expandafter{\thesisTitle}}
      \vspace{0.75cm}

      \large
      \textbf{\uppercase\expandafter{\identificatorulCursului}}
      \vspace{0.5cm}

      \normalsize
      \textbf{Teză de \programulDeStudii{}}

    \end{center}
  \vfill

  \normalsize

  \begin{flushleft}
    \begin{tabular}{ p{4cm} p{4cm} p{8cm}}
      Șef de departament:      & \underscores{4cm} & CAPCELEA Titu, \\
                               &                   & doctor în științe fizico-matematice, \\
                               &                   & conferențiar universitar \\
      Conducătorul științific: & \underscores{4cm} & MARIN Maria, \\
                               &                   & doctor, conferențiar universitar \\
      Autor:                   & \underscores{4cm} & \authorName, \\
                               &                   & student din grupa IA1901 \\
    \end{tabular}
  \end{flushleft}

  \vspace{1cm}

  \begin{center}
    \textbf{Chișinău -- 2022}
  \end{center}

\end{titlepage}

\clearpage
\tableofcontents

\clearpage
\unnumberedChapter{Lista abrevierelor}
\begin{acronym}
  \acro{CI/CD}{Continuous Integration / Continuous Delivery}
  \acro{DSL}{Domain-Specific Language}
  \acro{AOT}{Ahead of Time}
  \acro{DLL}{Dynamically-Linked Library}
  \acro{API}{Application Programming Interface}
\end{acronym}

\clearpage
\unnumberedChapter{Adnotare}

\textbf{la teza de licență ``\thesisTitle'', a studentului \authorName{}, grupa \uniGroupName{}, programul de studii \programulDeStudii.}

\textbf{Teza constă din}: Introducere, \total{num_chapters} capitole, Concluzii generale și recomandări, Bibliografie \bibliographyEntryCount{} titluri.
Textul de bază cuprinde \usefulPageCount{} de pagini și \anexeCount{} de anexe.

\textbf{Cuvinte-cheie:}
\textit{Generarea codului, eliminarea codului boilerplate, programarea declarativă,
jocuri video, eficiență și plăcere a programatorului, Unity, C\#.}

\textbf{Actualitatea tezei} se manifestă în faptul că generarea codului poate face lucrul programatorilor mai plăcut și mai eficient,
eliminând codul repetitiv, complex, sau presupus la erori, poate spori eficiența sau
necesitățile de memorie a programei, în special importante în dezvoltarea jocurilor video.

\textbf{Scopul și obiectivele cercetării} constă în elaborarea și argumentarea unui generator de cod, folosirea lui pentru programarea jocurilor.

Pentru realizarea scopului s-au formulat următoarele obiective:
\begin{enumerate}
  \item studiul soluțiilor existente pentru generarea codului,
  \item identificarea faptului că ele nu corespund cerințelor sau nu sunt practice,
  \item dezvoltarea unui sistem de generare a codului extensibil prin plugin-uri și ușor de utilizat.
\end{enumerate}

\textbf{Rezultatele preconizate și obținute} rezumă în (1) analiza soluțiilor existente pentru generarea codului (2) implementarea nucleului generatorului de cod, (3) suportului pentru plugin-uri, (4) demonstrarea unor plugin-uri utile, (5) folosirea generatorului de cod într-un proiect real.

\textbf{Problemele importante rezolvate} sunt generarea codului repetetiv, complicat sau presupus la erori, dacă scris manual, pe baza codului sursă; lipsa de capacități de metaprogramare în C\#.

\textbf{Valoarea aplicativă} constă în faptul că generarea codului înlocuiește codul asemănător scris manual, predispus la erori, dificil și anevoios de menținut, deci sporește eficiența și plăcerea programatorului.



\unnumberedChapter{INTRODUCERE}

\markpage{usefulStuffBegin}

\textbf{Actualitatea și importanța temei.}

Dezvoltarea jocurilor video este un domeniu important în ziua de azi.
Dezvoltarea lor practică și eficientă necesită mai multe instrumente, ca o modalitate de rendering a mesh-elor sau a imaginilor pe ecran, o modalitate de user input, scripting etc.

Motorul de joc Unity a făcut limbajul C\# popular pentru scripting în jocuri video.
Așadar, ușurarea programării în C\# poate aduce la un proces de dezvoltare mai plăcut și mai productiv pentru programatori de jocuri în Unity, sau în alte medii unde se folosește acest limbaj de programare.

C\# nu este un limbaj perfect.
Este dificil să se scrie codul declarativ fără să se utilizeze reflexie runtime care este lentă și alocă multă memorie excesivă.
Uneori necesită mai mult cod boilerplate sau cod mai puțin eficient sau care să consume mai multă memorie chiar pentru a atinge lucruri simple.

În mai multe cazuri, însă, acest cod poate fi generat pe baza fișierelor sursă inițiale.
Codul care să genereze acest boilerplate dorit poate fi mai ușor de înțeles decât codul băzat pe reflexie runtime, și trebuie să fie scris doar o singură dată, eliminând codul boilerplate dat pentru întotdeauna.
Codul generat va fi echivalent cu acel cod boilerplate, însă nu trebuie fi scris de mână de fiecare dată, și nu trebuie să fie sincronizat cu codul inițial — acestea se vor face automat de către generatorul de cod.


\textbf{Scopul și obiectivele.}

În această lucrare autorul proiectează, explică și elaborează un generator de cod.
Generatorul final poate fi utilizat ușor în mai multe proiecte, poate fi extins dinamic utilizând plugin-uri care să conțină logica specifică de analiză a codului sursă și de generare a codului nou.
Se demonstrează niște exemple de utilizare a generatorului de cod.
Se arată încă cum generatorul de cod poate fi integrat într-o aplicație de linie de comandă centralizată care să se utilizeze într-un pipeline \ac{CI/CD}.

\textbf{Suportul metodologic și tehnologic.}

Generatorul de cod este un instrument realizat în limbajul C\#, pe baza platformei {{.}NET} 6 și a lui Roslyn care este un set de librării și instrumente pentru analiza codului sursă C\#.
Generatorul de cod a fost testat și utilizat în practică în Unity.
Instrumentul a fost elaborat după necesitate în dezvoltare și reiese întreg din experimentare și experiența autorului.

\textbf{Noutatea stiințifică/originalitatea.}

În general, generatorul de cod a fost proiectat și elaborat după necesitățile autorului, din cauza lipsei de așa instrument general.
Autorul utilizează acest instrument în proiectele proprii și planifică să-l perfecționeze și să-l facă mai modular și mai ușor de utilizat.

\textbf{Valoarea aplicativă.}

Produsul obținut poate fi utilizat pentru generarea codului în orice proiect ce urmează,
cu posibilitatea de a crea plugin-uri personalizate, destinate unui proiect concret,
pentru a ușura realizarea scopurilor specifice acestuia.

\textbf{Sumarul tezei.}

În această lucrare se argumentează și se elaborează un generator de cod C\# flexibil și extensibil care poate fi utilizat pentru a ușura și a face mai plăcută programarea în C\#, și pentru a spori eficiența programatorului în implementarea unelor soluții.

Primul capitol, "\nameref{intro_chapter_id}", aduce informații generale despre limbajul de programare C\#, alude la faptul că experiența programării în C\# poate fi îmbunătățită prin generare a codului repetetiv, și explică istoriografia problemei.
Al doilea capitol, "\nameref{architecture_chapter_id}", concretizează cerințele la generator de cod și prezintă arhitectura generală a lui care reiese logic din cerințele specificate.
Al treilea capitol, "\nameref{implementation_chapter_id}", urmează implementarea generatorului de cod și structura generală a plugin-urilor, precum și aduce niște exemple ale lor.


\chapter{Generarea codului în limbajul de programare C\#}\label{intro_chapter_id}

\section{Argumentarea necesității generării codului în C\#}

\subsection{Capacitățile și deficiențele limbajului de programare C\#}

{C\# este un limbaj de programare modern, posedă caracteristici utile și practice}\cite{tour_of_csharp}, printre care:
\begin{itemize}
  \item Tipizarea statică;
  \item Un runtime inteligent;
  \item Un colector de gunoi integrat, util pentru programarea de uz general;
  \item O librărie de clase extinsă și testată în timp, etc.
\end{itemize}

Cu toate că C\# este ``mediul'' acestei lucrări, nu se va descrie în întregime,
deoarece importanta este esența problemei care constă în faptul că, cu toate că limbajul acesta este destul de capabil, este și destul de limitat.

Cel mai important moment pentru autor este posibilitatea executării sau generării codului,
posibilitatea performării reflexiei asupra tipurilor în timpul compilării.
Să se menționeze, că C\# deja permite reflexia asupra tipurilor și generarea codului, însă abordarea lui este că deleghează totul la timpul rulării, deci reflexia runtime și emisia codurilor IL, respectiv.
Aceste tehnici, însă, sunt dificile de utilizat și codul care le folosește este predispus la erori.
Însă, dacă s-ar putea să se genereze fișiere în timpul compilării, sau înainte de compilare, și ca aceste fișiere să conțină codul regular, sigur de tip, aceste erori ar fi prinși în timpul compilării.
Adică, codul pur și simplu nu s-ar compila, cu indicarea concretă a erorii, în loc de a da crash în timpul rulării.

Analiza tipurilor în timpul compilării (sau înainte de compilare, într-un pas aparte), în loc de aceasta în timpul rulării, permite și analiza mai profundă a tipurilor, folosirea structurilor de date mai avansate, ca grafuri, lucrul cu informații mai bogate despre simboluri în codul sursă, etc.
Dacă această analiză nu este delegată la timpul rulării ci este executată în prealabil, salvează timpul de execuție și memoria RAM valoroasă în timpul rulării, care sunt în special importante în jocuri video.

Generarea codului poate fi folosită și pentru a elimina codul boilerplate, sau pentru a genera wrapper-uri sau funcții ajutătoare.

\subsection{Exemplu: implementarea interfețelor prin compoziție}

Urmează o instanță posibilă a apăriției codului boilerplate, unde dorim să implementăm o interfață prin compoziție\cite{composition_interface_boilerplate}.
Deci fie o astfel de interfață:

\begin{minted}{csharp}
public interface IExample
{
    void A();
    void B();
    void C();
    void D();
    // ...
}
\end{minted}

Acum fie că dorim să creăm o structură, unde să avem o implementare a acestei interfețe.
Deoarece trebuie să fie o structură, dorim numaidecât să folosim compoziția, și nu putem folosi moștenirea.
Încă dorim ca această structură să implementeze și ea interfața aceasta, ca să poată fi folosită în generics.

În alte cuvinte:

\begin{minted}{csharp}
public struct Composition : IExample
{
    private IExample _impl;
}
\end{minted}

Este clar că acum trebuie să implementăm această interfață.
Deci, unica soluție care C\# ne propune este următoarea:

\begin{minted}{csharp}
public struct Composition : IExample
{
    private IExample _impl;

    void A() { _impl.A(); }
    void B() { _impl.B(); }
    void C() { _impl.C(); }
    void D() { _impl.D(); }
    // ...
}
\end{minted}

Este clar, că așa abordare în primul rând este o repetare proastă a codului, aducerea zgomotului fără sens în cod.
Însă cel mai rău aspect este că, acum, dacă s-ar schimba interfața \texttt{IExample}, ar trebui să fie schimbat și acest tip.
Da, nu e nimic dacă este doar un singur astfel de tip, dar aceste lucruri se acumulează și pot face codul mai anevoios de modificat, sporesc fricția între limbajul de programare și programatorul. \footnote{
  O altă soluție aici ar putea fi supraîncărcarea castului implicit în acest tip integrat,
  însă supraîncarcarea casturilor implicite în interfețe nu este permisă în C\#.
}

Cu generarea codului, ar putea fi posibilă o astfel de soluție, simplă, clară, ușoară de utilizat, și rezistentă la schimbări ale interfeței:

\begin{minted}{csharp}
public partial struct Composition : IExample
{
    [ForwardMethodCalls]
    private IExample _impl;
}
\end{minted}

Iar codul generat deja să conțină aceste implementări, într-un fișier aparte:

\begin{minted}{csharp}
public partial struct Composition
{
    void A() { _impl.A(); }
    void B() { _impl.B(); }
    void C() { _impl.C(); }
    void D() { _impl.D(); }
    // ...
}
\end{minted}


\subsection{Exemplu: metodele ajutătoare pentru enumuri flag}

Fie un astfel de enum cu flaguri:

\begin{minted}{csharp}
public enum Flags
{
    Shy = 1 << 0,
    Brave = 1 << 1,
    Strong = 1 << 2,
    Beautiful = 1 << 3,
}
\end{minted}

Și folosirea lui în cod tipică:

\begin{minted}{csharp}
Flags flags = Flags.Shy | Flags.Brave;

// Check if it has the Shy flag
assert((flags & Flags.Shy) != 0);

// Check if it has both the Shy and the Brave flags
assert((flags & (Flags.Shy | Flags.Brave)) == (Flags.Shy | Flags.Brave));

// Check it's neither Strong nor Beautiful
assert((flags & (Flags.Strong | Flags.Beautiful)) == 0);

// Clear the Shy flag
flags &= ~Flags.Shy;

// Conditionally set/unset the Beautiful flag
if (true)
    flags |= Flags.Beautiful;
else
    flags &= ~Flags.Beautiful;
\end{minted}

Acestea pot fi puse în metode de extensiune și atunci uzul lor devine mai descriptiv:

\begin{minted}{csharp}
Flags flags = Flags.Shy | Flags.Brave;

// Check if it has the Shy flag
assert(flags.Has(Flags.Shy));

// Check if it has both the Shy and the Brave flags
assert(flags.Has(Flags.Shy | Flags.Brave));

// Check it's neither Strong nor Beautiful
assert(flags.DoesNotHaveEither(Flags.Strong | Flags.Beautiful));

// Clear the Shy flag
flags.Unset(Flags.Shy);

// Conditionally set/unset the Beautiful flag
flags.Set(Flags.Beautiful, true);

// ...

public static class FlagsExtensions
{
    public static Flags Has(this Flags source, Flags flags)
    {
        return (source & flags) == flags;
    }
    public static Flags DoesNotHaveEither(this Flags source, Flags flags)
    {
        return (source & flags) == 0;
    }
    public static void Unset(this ref Flags source, Flags target)
    {
        source &= ~target;
    }
    public static void Set(this ref Flags source, Flags target, bool isOn)
    {
        if (isOn)
            source |= target;
        else
            source &= ~target;
    }
}
\end{minted}

Problema este că trebuie să se scrie aceste metode pentru toate tipurile flag care sunt în cod.
Când apare un nou astfel de tip, trebuie să se copieze acest cod, și să se plaseze undeva, cu denimirea tipului de intrare schimbată.
C\# nu propune o soluție comodă pentru această problemă: este pur și simplu imposibil să scrieți astfel de metode care să lucreze cu orice tip enum flag.
Aceasta este posibil de realizat cu IL emission, dar nu cred că merită.

Autorul propune următoarea soluție declarativă, explicată mai bine în capitolul 3:

\begin{minted}{csharp}
[NiceFlags]
public enum Flags
{
    // ...
}
\end{minted}

Aceasta generează toate acele metode automat.

\subsection{Mai multe exemple}

Cele două exemple clar arată capacitățile generării codului în eliminarea boilerplate-ului.
Însă acesta nu este singurul lor caz de utilizare.
Să se menționeze această prezentare\cite{microservices_code_generation} unde autorul demonstrează cum compania lui generează codul pentru endpoint-uri \ac{API} din fișiere agnostice de configurare.
Protobuf\cite{protobuf} care generează codul pentru mai multe limbaje, realizând protocolul personalizat dintr-o descriere într-un \ac{DSL}.
Message Pack\cite{message_pack_github} care permite emiterea codului IL pentru serializarea eficientă a datelor, dar permite și generarea codului \ac{AOT}.
Încă un exemplu: consola și comenzile integrate în joc\cite{command_terminal}.


\section{Istoria problemei}

După ce autorul a început să studieze și să practice programarea independentă în C\#, și anume în proiectul Hopper descris în teză de an, au devenit evidente deficiențele acestui limbaj.
Folosind o abordare directă, a fost conceput și creat un prototip al generatorului de cod, cuplat cu proiectul în care a fost utilizat.
Acest generator de cod s-a descris pe scurt în teză de an al autorului.

După teză de an, autorul a continuat să experiementeze cu aceste concepte, implementând baza unui alt joc, conceput cu două ani înainte de perfectarea tezei de an.
În timp de aproape o lună și jumătate, a fost creat un proiect-șablon în Unity cu toate instrumentele necesare: generatorul de cod, divizarea modulară a asamblelor C\# în Unity, integrarea unui terminal virtual în joc, o interfață de consolă centrală\cite{particular_project}.
Deci, generatorul de cod a fost inițial adaptat la nevoile acestui proiect, însă autorul a văzut oportunitatea să-l modularizeze printr-o arhitectură pe baza plugin-urilor, ceea ce și se explică în această lucrare.

\section{Roslyn}


Roslyn este un ansamblu de librării și instrumente pentru analiza și compilarea codului C\#, pentru C\#.
De fapt, însuși compilatorul C\# este implementat pe baza acestor librării Roslyn.
Roslyn combină întregul pipeline de compilare: tokenizarea, analiza sintactică, analiza semantică, generarea codului executabil, expuzând toate aceste operații.

Cel mai des, Roslyn este utilizat pentru analizori, adică programe care analizează codul sursă și detectează erori logice, posibil propunând o remediere\footnote{``code fix''}, sau adaugând operații utile în IDE-uri, de exemplu, ``implement methods'', ``extract into a local function''.
De fapt, repertoriul Roslyn conține o mulțime de analizori gata pentru folosire.

Însă Roslyn a fost demult utilizat și pentru generatori de cod ad hoc, adică unele programe care produc codul sursă adaugător, des generat pe baza codului sursă inițial, create pentru un scop specific.
Așa programe manual citesc fișierele sursă, manual le parsează conținuturile, manual le analizează și le produc output-ul.
Deci așa programe de fapt fac următoarele lucruri:

\begin{itemize}
  \item Configurarea --- din ce mapă sau proiect să fie citite fișierele;
  \item Parsarea --- citirea fișierelor sursă și generarea obiectului de compilare;
  \item Analiza la nivel sintactic sau semantic al codului sursă;
  \item Generarea codului.
\end{itemize}

Un exemplu este generatorul de cod Message-Pack\cite{message_pack_github}.
Kari, generatorul de cod descris în această lucrare, a fost dezvoltat inițial după aceeași arhitectură ca și codul acestui proiect, însă autorul a prins oportunitatea să-l generalizeze.

Decizia să se folosească C\# și Roslyn pentru a implementa generatorul de cod a fost o decizie evidentă, deoarece nu există nici o altă librărie care este asemănător de capabilă.

\section{Source generators în {{.}NET}}

{{.}NET} 5 a introdus un concept nou --- Source Generators (generatori de sursă)\cite{source_generators}.
Acestea sunt de fapt analizorii care primesc la intrare arborele sintactic, și returnează codul sursă generat.
Acestea integrează cu compilatorul, deci funcționează pe baza arborelui sintactic al compilatorului.

Generatorii de sursă permit accelerarea generatorilor de cod personalizate, prin reutilizarea configurației și a datelor despre cod deja existente în timpul compilării în memoria compilatorului.
Aceasta permite generatorilor de cod personalizate să facă mai puțin lucru irelevant, și să lucreze cu abstracțiunile corespunzătoare.

Însă ei au și mai multe limitații:

\begin{itemize}

  \item După experiența autorului, ele pot fi folosite doar cu MSBuild, sistemul de build al lui Microsoft.
  MSBuild este renumit pentru scalabilitatea proastă --- un proces de build chiar puțin netrivial devine aproape imposibil de suportat.

  \item Generatorii de sursă trebuie să folosească și ele fișiere MSBuild pentru a-și specifica configurația\cite{source_generators_msbuild_configuration} și pentru a fi distribuite ca pachete NuGet,
    însă în experiența autorului crearea de așa fișiere MSBuild pentru integrarea ușoară în alte proiecte devine foarte complicată și este predispusă la erori.

  \item Nu se poate folosi toate capacitățile framework-ului --- sunt dintr-o cauză limitate la {{.}NET} Standard 2.0.

  \item Sunt considerate o capacitate avansată și experimentală, și nu sunt documentate bine.

  \item Sunt destul de dificile de setat și de utilizat.

  \item Clar că sunt suportate doar pe versiunile cele mai noi ale compilatorului, și clar că nu pot fi utilizate în Unity, deoarece versiunea compilatorului acestuia este învechită.

\end{itemize}

Așadar, după opinia autorului, acestea nu sunt practice la moment.

Crearea unei soluții personale ar fi mai ușor și mai practic:

\begin{itemize}
  \item S-ar avea mai mult control asupra întregului proces, deoarece codul ar fi simplu și ușor de modificat.

  \item Realizarea unei soluții destul de bune din punct de vedere al uzului practic nu este atât de complicată.

  \item Soluția ar putea fi utilizată în Unity, precum și în orice alt proiect C\#, indiferent de dacă folosește sau nu MSBuild și indifirent de versiunea compilatorului utilizată în acel proiect.

  \item Reutilizarea configurației tot poate fi asigurată\footnote{cel puțin parțial, descris și în continuare.}.
\end{itemize}

\chapterConclusionSection{intro_chapter_id}

În acest capitol s-a discutat și s-a exemplificat valoarea practică a generatorilor de cod, și s-a argumentat de ce soluțiile existente nu sunt practice.
A fost introdusă și ideea de fluidizare a procesului utilizând un sistem care să reutilizeze o singură sursă de informație despre structura codului, făcând mai puțin lucru în total, așadar întregul proces să devină mai rapid în general.

\chapter{Arhitectura aplicației}\label{architecture_chapter_id}

\section{Concretizarea cerințelor pentru generator de cod}

Este clar că pentru a putea realiza un produs software trebuie să se știe ce exact se cere de el.
În cazul unui generator de cod, se poate formaliza cerințele funcționale de bază la nivel înalt în următorul mod:

\begin{enumerate}
  \item Se cere ca generatorul de cod să citească fișierele sursă cu codul de intrare.
  \item Se cere ca să se genereze codul de ieșire, pe baza unei logici specifice. Ca un exemplu concret, enumuri flag.
  \item Se cere ca generatorul de cod să nu fie prea lent.
        Cu toate că aici nu sunt date concrete, această cerință se consideră funcțională, deoarece este foarte importantă.
\end{enumerate}

Prima cerință poate fi concretizată mai tare:

\begin{itemize}
  \item Trebuie să se poată controla ce fișiere sursă vor fi procesate. De exemplu, toate fișierele dintr-o mapă.
  \item Dacă codul logicii de generare necesită parametrizarea suplimentară, trebuie să fie posibil de a o furniza.
  \item Configurarea să se facă prin linia de comandă sau prin fișiere de configurare.
  \item Se cere să se integreze cu sistemul de structurare a subproiectelor folosit de Unity, anume asmdef-uri.
  \item Se cere ca fișierele sursă să fie interpretate corect, și ca codul generat să fie parametrizat de către codul de intrare. În alte cuvinte, se dorește o modalitate de a putea procesa codul de intrare într-un mod standardizat.
\end{itemize}


Se concretizează a doua cerință în modul următor:

\begin{itemize}
  \item Codul de analiză și de generare a codului să fie scris în limbajul C\# pe baza platformei {{.}NET} 6, să poată accesa toate \ac{API}-urile specifice acestuia.
  \item Această logică trebuie să poată analiza o reprezentare abstractă a codului sursă de intrare și să poată genera output-ul, ca text.
  \item Se cere ca să fie ușor de creat fișiere cu codul care să conforme formatării corecte și care să nu lupte cu simboluri din codul inițial.
  În alte cuvinte, se cere ca librăria generatorului de cod să ofere \ac{API}-uri utile pentru generarea codului și lucrul cu simboluri din cod.
  \item Deoarece se dorește ca codul de intrare să fie declarativ, să folosească extensiv atribute aplicate la tipuri și la membrii lor, ar fi foarte
  comod dacă codul generat să poată automat conțină definițiile atribute acestea, partajate între codul de intrare care să le folosească drept atribute,
  și logica de analiză și generare care să le caute în reprezentare abstractă a codului sursă și să le inspecteze.
  \item Logica acestui analizor se va schimba des, și analizorii noi vor fi adăugați, de aceea se cere ca acest nivel să fie cât mai flexibil, să fie posibil să se modifice și să se augmenteze ușor.
\end{itemize}


Ultima cerință se obține prin paralelizare.

\section{Schița arhitecturii}

În primul rând se dorește să se precizeze încă o dată etapele concrete de funcționare a sistemului propuse care reies în mod natural din analiza superficială a cerințelor:

\begin{itemize}
\item Configurarea --- parsarea argumentelor liniei de comandă, sau a fișierelor de configurare; validarea lor.
\item Descoperirea fișierelor sursă și clasificarea lor între subproiecte (de exemplu, după asmdef-uri în Unity, sau după mape).
\item Citirea conținutului fișierelor sursă, convertarea textului în reprezentarea abstractă a codului.
\item Analiza codului.
\item Generarea codului.
\end{itemize}

Se poate ușor observa că primele 3 puncte vor fi aceleași pentru orice logică de analiză și de generare a codului, și corespund la prima cerință din lista adusă anterior.
Analog, ultimele două sunt legate la a doua cerință.
Să se țină minte că se cere ca acest nivel să fie cât mai flexibil.

Aceasta natural aduce la următoarea arhitectură:

\begin{itemize}
  \item Să existe un orchestrator, care să accepte configurația din linia de comandă, să citească fișierele sursă și să le converteze în reprezentarea codului abstractă.
  \item Să existe mai multe plugin-uri, care să analizeze și să genereze output-ul pentru această reprezentare abstractă.
  \item Orchestratorul va încărca plugin-urile în timpul rulării, conform configurației, le va inițializa, iarăși, conform configurației, și le va da codul ca datele de intrare. El va primi output-ul generat de către ele și îl va scrie în fișierele corespunzătoare de ieșire.
\end{itemize}

Arhitectura propusă poate fi eventual subdivizată și la mai multe etape, prin divizarea orchestratorului la mai multe părți.
Însă, nu este numaidecât necesar de făcut acest lucru, deoarece așa arhitectură deja corespunde cerințelor.

O divizare utilă însă ar fi cel puțin să se extragă etapa de citire a configurației din orchestrator într-un modul ce ține de interpretarea comenzilor din linie de comandă și/sau fișierelor de configurare.
Acest modul ar putea fi reutilizat în alte locuri în cod, sau poate fi substituit cu o librărie.

\section{Plugin-uri}

Ideea principală a sistemelor băzate pe plugin-uri este ca să fie posibil să se augmenteze logica sistemului în timpul rulării, adică fără să se schimbe codul acestui sistem.
Acesta presupune că trebuie să existe o modalitate de a descoperi în timpul rulării codul logicii care trebuie să fie executat.
Acest cod atunci s-ar putea schimba fără a afecta logica sistemului original.

În alte cuvinte, totul ce sistemul va trebui să facă va fi administrarea și integrarea acestor plugin-uri.
Însăși logică va fi conținută în aceste plugin-uri și nu va fi o parte integrală a sistemului.

Utilizarea plugin-urilor reprezintă o soluție care foarte bine corespunde cerințelor: în primul rând, restul sistemului este decuplat de nivelul plugin-urilor, iar acesta este foarte flexibil, adică ușor de modificat și de augmentat.

În C\#, există \ac{DLL}-uri --- librării care permit să încarce codul în timpul rulării, să linkeze toate funcțiile necesare, să descopere tipurile prezente în această librărie și să facă ceva cu ele.
În cazul generatorului de cod dat, dorim ca aceste plugin-uri să poată fi inițializate, să analizeze codul sursă și să genereze codul nou.
Cea mai ușoară modalitate de a asigura acest lucru este de a defini o interfață cu toate aceste acțiuni ca metode, iar în timpul rulării de a căuta toate tipurile care implementează această interfață, după ce pot fi instanțiate și utilizate, executând metodele acestei interfețe.

În plus, deoarece se presupune că plugin-urile sunt independente, putem paraleliza în mod trivial executarea lor\footnote{Pot fi și dependente, însă această problemă tot poate fi soluționată fără a anula utilizarea plugin-urilor și a argumentului dat.}.

\section{Fluxul de lucru cu generatorul de cod}

Generatorul de cod trebuie să fie ușor de utilizat.
Configurarea nu trebuie să ia mult timp și trebuie să fie simplă.
De aceea s-a decis că generatorul de cod trebuie să funcționeze ca o aplicație de consolă tipică: să fie invocată la consolă, unde utilizatorul ar da toate argumentele și opțiunile.
Este clar că aceste opțiuni de obicei vor fi ascunse într-un script executabil, de exemplu, ca un fișier bat pe Windows.

Încă, configurația generală pentru un anumit proiect poate fi pusă într-un fișier json.
Așa fișier poate conține configurația parametrilor concrete pentru plugin-uri, sau configurația de felul care proiect din acestea este principal, cum să fie numită mapă de ieșire, etc.
\inputminted{js}{../race/game/kari.json}


S-a decis ca toate plugin-urile să fie importate ori dintr-o singură directorie, ori individual după cale la \ac{DLL}-uri.
Încă se admite instalarea prin NuGet, pentru a putea a le împărtăși ușor cu lumea, însă procesul de lucru cu NuGet gol este mult mai complicat decât folosirea submodulelor git și setarea individuală a calelor la \ac{DLL}-uri într-un script, de aceea această funcționalitate nu se folosește la moment.

Configurarea plugin-urilor tot se face prin consola.
Ele primesc argumente în același fel ca și orchestratorul.

Din punct de vedere a integrării cu instrumente, invocarea directă ar fi mai bună, ca de exemplu linkarea la librării C, însă invocarea unui proces la consolă tot este destul de ușor.

Deci, comanda-exemplu de invocare ar putea fi următoarea:

\begin{minted}{text}
kari -configurationFile kari.json -pluginPaths plugin1.dll,plugin2.dll,plugin3.dll
\end{minted}

Aceasta ar invoca generatorul de cod cu plugin-urile \textit{plugin1}, \textit{plugin2} și \textit{plugin3}, unde restul configurației se ia din fișierul \textit{kari{.}json}.
După aceasta, programul generează codul, ori arată erori, posibil cu mesajul de ajutor care arată toate opțiunile.


\chapterConclusionSection{architecture_chapter_id}

În acest capitol s-au stabilit cerințele principale pentru generatorul de cod și s-a discutat arhitectura generală a sistemului.
S-a decis că o arhitectură băzată pe plugin-uri, unde orchestratorul dirijează o mulțime de plugin-uri, soluționează problema conform cerințelor.
S-a discutat și fluxul de lucru dorit, mai precis, faptul că va fi o aplicație din linia de comandă.

\chapter{Implementarea sistemului}\label{implementation_chapter_id}

\section{Implementarea generatorului de cod}

\subsection{Configurarea}

După cum s-a menționat, configurarea se va face din linia de comandă și/sau prin fișiere json de configurare.
Autorul a decis să creeze codul propriu pentru lucrul acesta, cu toate că deja există mai multe librării care fac același lucru.
Autorul ori nu a fost satisfăcut cu \ac{API}-ul lor, ori cu lipsa opțiunilor dorite.

Deci a fost realizat un \ac{API} declarativ pentru specificarea opțiunilor particulare care o clasă specifică va lua.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Generator_KariCompiler}.
pentru un exemplu complet.

Următorul cod transmite argumentele primite la consolă la parser, care își completează structura de date internă cu toate opțiunile prinse, pentru o mapare mai eficientă în continuare:
\inputminted[firstline=126, lastline=132]{cs}{../Kari/source/Kari.Generator/KariCompiler.cs}

Aici se arată codul parțial al clasei ce va primi argumentele din consolă, mapate la tipurile câmpurilor.
Cum se poate observa, este utilizat atributul \texttt{Option} pentru a atinge un \ac{API} declarativ.
Acestea sunt scanate în timpul rulării de către parser, utilizând reflexie runtime, pentru a obține informații despre obiect la care să fie bindate valorile argumentelor.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Generator_KariCompiler}, rândurile 21-87.

Urmează un exemplu de utilizare în codul generatorului de cod.
Metoda \texttt{FillObjectWithOptionValues} umple obiectul dat cu valorile din structura de date internă, și returnează o listă cu toate erorile care s-au îmtâmplat în timpul bindării parametrilor.
\inputminted[firstline=147, lastline=155]{cs}{../Kari/source/Kari.Generator/KariCompiler.cs}

Aceeași metodă este utilizată și pentru bindarea valorilor la câmpurile ``administratorilor'' plugin-urilor.
Administratorii sunt obiecte care dirijează procesul de execuție a plugin-urilor.
\inputminted[firstline=208, lastline=221]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}


Interesant este momentul că, când vreo opțiune este menționată în parser, ea este marcată cu un flag.
După ce toate opțiunile au fost colectate, se poate obține toate opțiunile care nu au fost marcate cu un astfel de flag --- argumente superfluoase.
Opinia autorului este că prezența unor argumente superfluoase mereu trebuie să fie considerată ca o eroare critică.
În plus, toate așa erori trebuie să fie explicit afișate.
\inputminted[firstline=446, lastline=460]{cs}{../Kari/source/Kari.Generator/KariCompiler.cs}

Un exemplu de output:

\begin{minted}{text}
kari -helloworld -mynameisanton
[Master]: Unrecognized option: helloworld
[Master]: Unrecognized option: mynameisanton
\end{minted}


Mesajele de ajutor au fost implementate utilizând librăria Spectre Console\cite{spectre_console_github}, în particular, funcționalitatea de creare a tabelelor.

% An example not included, because latex cannot display it
% Could do a figure, but meh
% Deci, o parte a mesajul de ajutor arată cam în modul următor:

Codul parser-ului este foarte simplu.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Arguments_ArgumentParsing}.
Pe scurt:

\begin{itemize}
  \item Toate opțiunile sunt colectate și păstrate într-un tablou asociativ, numele $\rightarrow$ valoarea.
  \item Toate fișierele menționate prin opțiunea \texttt{configurationFile} sunt încărcate și sălvate într-o listă.
  \item Metoda \texttt{FillObjectWithOptionValues} primește la intrare un obiect de orice tip, îi inspectează câmpurile, utilizând reflexia runtime, și performă conversiunile din tip șir în tipul câmpului corespunzător.
  \item Metoda \texttt{GetHelpFor} construiește un tabel, utilizând aceeași reflexie runtime.
  \item Metodele \texttt{GetUnrecognizedOptions} și \texttt{GetUnrecognizedOptionsFromConfigurations} se iterează prin toate opțiunele nemarcate și le returnează numele.
  Să se noteze că \ac{API}-ul nu este final.
  A fost realizat în durata de aproape o zi și în continuare ceva modificat după necesitățile aplicației.
\end{itemize}

Să se noteze că \ac{API}-ul nu este final.
A fost realizat în durata de aproape o zi și în continuare ceva modificat după necesitățile aplicației.


\subsection{Incărcarea plugin-urilor}

După cum s-a menționat anterior, codul plugin-urilor este distribuit și încărcat prin \ac{DLL}-uri.
Pentru aceasta, se folosesc funcțiile \texttt{Assembly.LoadFile} și \texttt{GetExportedTypes}, după ce se realizează filtrarea tuturor tipurilor, anume căutarea tipurilor care implementează interfața \texttt{IAdministrator}.
Aceste tipuri deja pot fi instanțiate prin reflexie.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_AdministratorFinder}.

După ce s-au încărcat plugin-urile, nu sunt inițializate imediat.
La început, ele iau argumentele de linie de comanda, iar după aceasta sunt încărcate toate proiectele cu codul sursă de intrare.
Plugin-urile realizează inițializarea suplimentară după ce devin accesibile toate proiectele cu codul sursă și după ce au primit toate argumentele, deoarece validarea argumentelor deseori se face pe baza proiectelor sau tipurilor existente în compilație.
De exemplu, unele plguin-uri generează un fel de output agnostic, de aceea doresc să știu care este proiectul comun, pentru a scrie fișierele acolo, însă denumirea proiectului comun nu se cunoaște înainte ca proiectele utilizatorului au fost descoperite.

\subsection{Descoperirea fișierelor sursă}

Kari permite mai multe moduri de intrare (de descoperire a fișierelor sursă):

\begin{itemize}
  \item \texttt{UnityAsmdef}.
    Unity are formatul său pentru definirea subproiectelor, numit asmdef.
    Este un fișier JSON care conține metadatele despre subproiectul dat, precum și dependențele lui.
    Divizarea fișierelor de sursă între mai multe așa proiecte este benefică pentru proiecte mari, deoarece reduce timpul de compilare incrementală.
    Acest mod de intrare descoperă toate fișierele cu extensiunea \texttt{asmdef} imbricate într-o directorie dată, și prescrie toate fișierele în același folder acestui subproiect.

  \item \texttt{ByDirectory}. Acest mod de intrare presupune gruparea fișierelor de intrare după subdirectorii imediate ale directorii de intrare.

  \item \texttt{Monolithic}. Toate directoriile sunt considerate ca un singur proiect.

  \item \texttt{Autodetect}. Ghicește modul de intrare din structura sistemului de fișiere.
\end{itemize}

Această logică se conține într-o singură funcție, cu mai multe funcții locale imbricate.
Codul este foarte simplu, operând cu \ac{API}-urile sistemului de fișiere și în cea mai mare parte conține validări.
În dependența de cerințe viitoare la proiect, acest cod poate fi extras în încă o etapă opțională de descoperire.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_285_598}.

Acest cod încă gestionează căutarea acelor două proiecte, anume proiectului \texttt{Common} care reprezintă un proiect cu cod agnostic care conceptual nu poate referi la nici un alt proiect, și a proiectului \texttt{Root}, adică proiectului care să conțină funcțiile de inițializare și care conceptual poate referi la orice alt proiect.
Fiecare mod de intrare are logica sa de căutare a proiectelor acestea, selectată în așa fel ca să aibă cât mai mult sens în scopul modului de intrare selectat.

\subsection{Pornirea plugin-urilor cu codul sursă ca parametri de intrare}

Obiectul care permite reprezentarea abstractă a codului sursă în Roslyn se numește o compilație.
Acest obiect poate fi creat din arbori sintactici care la rândul său sunt creați din codul sursă, citit din fișiere sursă.
Crearea compilației nu poate fi paralelizată pe mai multe fire, însă generarea arborilor din textul sursă poate fi paralelizată.
Acestă paralelizare nu aduce beneficii mari, însă din testele autorului a accelerat timpul execuției cu aproape 10\%.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_604_664}.

După ce toții arbori s-au încărcat, se creează obiectul de compilație.
Acest obiect este după înțelegerea autorului în mare parte leneș, adică nu cachează atâtea multe simboluri.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_666_697}.

Plugin-urile de obicei lucrează la nivelul tipurilor sau al membrii lor.
De obicei se cere ca aceste simboluri (tipuri sau membrii) să fie anotate cu atributele folosite pentru configurarea codului generat pentru acest simbol, fiind descoperite și interpretate de către plugin-uri.
Cel mai importat simbol sunt tipurile definite de utilizator, de aceea ele sunt mereu cachate din arborii sintactici, ca să nu le facă pe plugin-uri să realizeze acest lucru.
Cacharea se face în mod paralel.
Această operație este destul de constisitoare.
După înțelegerea autorului, cere destul de multe resurse din acea cauză că crearea compilației este leneșă, deci analiza tuturor arborilor sintactice necesită cacharea leneșă a mai multor simboluri.
\inputminted[firstline=699, lastline=727]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

Fiecare plugin, în rândul său, face filtrarea proprie a tipurilor, colectând datele necesare.
Aceasta se face în metoda \texttt{IAdministrator.Collect} scopul căreia este să inițializeze toate datele necesare pentru generarea consecutivă a codului.
Deoarece procesarea mai multor simboluri ia destul de mult timp, acest proces este paralelizat între plugin-uri, care pot paraleliza procesul mai departe cum ele consider rezonabil.

După ce toate plugin-urile au terminat cacharea simbolurilor, are loc generarea codului prin invocarea metodei \texttt{IAdministrator.Generate} la toate plugin-urile.
Șirurile cu codul sursă de ieșire la început sunt generate aparte în memorie, adică nu sunt scrise imediat în fișiere.
Paralelizarea se face în același mod ca și la colectarea simbolurilor.

\subsection{Sălvarea output-ului}

Plugin-urile scriu codul de output al lor direct într-un bufer UTF-8 ca să fie posibil să scrie textul de ieșire direct în fișiere.
Se utilizează librăria ZString\cite{zstring_github}, cu toate că se planifică să se folosească capacitățile noi de interpolare a șirurilor fără alocările memoriei adăugate în {{.}NET 6}.\cite{string_interpolation_csharp_10}

Plugin-urile selectează explicit denumirile fișierelor în care doresc să scrie output-ul lor, însă aceste denumiri sunt doar hint-uri, și proiectul în care se dorește să fie generat fișierul.
Sistemul este liber să folosească alte denumiri pentru aceste fișiere, în funcție de \emph{modul de output} selectat.

Sunt 4 moduri de output:

\begin{itemize}
\item \texttt{CentralFile}. Output-ul este concatenat între toate proiectele, și scris într-un singur fișier.
\inputminted[firstline=1114, lastline=1129]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\item \texttt{CentralDirectory}. Output-ul este divizat între proiecte și put într-un folder de ieșire comun.
  Fiecare subfolder al acestui folder are denumirea proiectului pentru care a fost generat fișierul, și conține toate fișierele, ca solicitat de plugin-uri.
\inputminted[firstline=1064, lastline=1080]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\item \texttt{NestedFile}. Output-ul fiecărui proiect în parte este concatenat și scris în câte un fișier pentru fiecare proiect.
\inputminted[firstline=1131, lastline=1145]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\item \texttt{NestedDirectory}. Output-ul este divizat între proiecte și generat în căte un subfolder, cu denumirile fișierelor ca solicitat de plugin-uri.
\inputminted[firstline=1040, lastline=1057]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}
\end{itemize}

Înainte de a fi scris în fișier, codul generat este comparat cu conținutul fișierului existent, dacă un fișier cu aceeași denumire deja există.
Dacă conținuturile se diferă, conținutul fișierului existent se înlocuiește cu cel generat.
Aceasta se face, deoarece instrumentele ca MSBuild și Unity, cel puțin în unele versiuni, determină dacă trebuie să recompileze proiectul pe baza timestamp-urilor de modificare salvate în metadatele fișierelor.
Chiar dacă se înlocuiește conținutul unui fișier cu conținutul nou egal, timestamp-ul se schimbă, ce invocă o recompilare.
Din această cauză, dacă se admite ca generatorul de cod să nu aibă această verificare, rularea generatorului de cod de a două dată va invoca o recompilare.
Deoarece recompilarea în Unity este foarte lentă, luând pănă la 10 secunde, se câștigă destul de multe resurse dacă se folosește această verificare.
\inputminted[firstline=950, lastline=972]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

Se poate observa că se folosește cod asincron de scriere a datelor în fișiere, și codul este la un nivel destul de scăzut.
Acestea sunt în cea mai mare parte experimentările autorului și de fapt nu accelerează executarea.
Deci acest cod probabil va fi schimbat când autorul va găsi timpul pentru refactoring.

\section{Programarea plugin-urilor}

\subsection{CodeBuilder}

Când se realizează generarea codului, se dorește ca codul generat să fie formatat conform standardelor.
Formatarea corectă face codul mai ușor de citit și de înțeles pentru persoana care îl citește.
Pentru acest lucru a fost creat tipul \texttt{CodeBuilder} care simplifică procesul de indentare.
El are un contor pentru indentarea curentă, și o adaugă de atâtea ori, când codul se scrie pe o linie nouă.

Esența acestei utilități poate fi ilustrată în următorul cod:

\begin{minted}{csharp}
// UTF-8
public byte[] IndentationBytes { get; }

public int CurrentIndentationCount;
public void IncreaseIndent() => CurrentIndentationCount++;
public void DecreaseIndent() => CurrentIndentationCount--;

public void Indent()
{
    for (int i = 0; i < CurrentIndentationCount; i++)
        StringBuilder.AppendLiteral(IndentationBytes);
}

public void AppendLine()
{
    Indent();
    NewLine();
}
\end{minted}

A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Utils_CodeBuilder_19_184}.

Mai jos sunt prezentate și niște exemple de utilizare.

\subsection{Anotațiile}

Următorul caz de utilizare comun pentru majoritatea plugin-urilor sunt anotațiile (sau atributele).
Atributele sunt acel lucru care permite design-ul unor \ac{API}-uri declarative.
Este comod pentru ele să fie partajate între codul sursă al plugin-ului și cel al consumatorului.
Plugin-ul le-ar utiliza ca containeri pentru datele extrase din codul consumatorului, iar acela le-ar folosi pentru a stabili aceste date.
Astfel, același container este utilizat și pentru definirea datelor, și pentru manipularea lor.

Deci s-ar dori să se partajeze codul legat cu anotațiile între plugin-ul și consumatorul, însă cum să se realizeze acest lucru?
O soluție poate fi să se copieze fișierul sursă din sursa plugin-ului în codul consumatorului, dar nu ar fi comod să se facă aceasta manual, deoarece ar fi nevoie ca el să schimbe și în codul sursă al consumatorului când se schimbă interfața plugin-ului, și este încă un pas de setup, și trebuie să fie urmărit de source control, etc.
O soluție mult mai comodă ar fi ca plugin-ul să genereze acest fișier drept un fișier de ieșire al său.
Atunci, dacă plugin-ul a fost utilizat cu totul, acest fișier cu anotațiile va fi prezent numaidecât în proiectul consumatorului.
În plus, plugin-ul acum are posibilitatea să schimbe conținutul fișierului său cu anotațiile.

Problema este că C\# nu poate citi fișiere ca șiruri de text în timpul compilării, de aceea a trebuit să se realizeze un program aparte care să citească acest fișier cu anotațiile și să genereze un nou fișier cu o singură clasă statică, cu o singură constantă statică cu conținutul acestui fișier.
Deoarece acum este un program aparte și este posibil de făcut mai multe lucruri decât doar generarea acestei constante, a fost implementată și generarea boilerplate-ului asociat cu căutarea simbolurilor acestor anotații în codul de intrare analizat de plugin-uri.
I s-a dat denumirea \emph{Annotator}, deoarece lucrează cu anotațiile.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Annotator_Annotator}.

Acest instrument ori se integrează în procesul de build al plugin-urilor, ori fișierele generate sunt incluse în source control.
Fișierele targets și props din MSBuild distribuite cu Kari realizează integrarea acestui instrument în procesul de build al plugin-ului,
însă sistemul de build urmează să fie schimbat la ceva mai ușor de menținut.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_InternalPlugin}.


Referitor la căutarea tuturor simboluri cu un anumit atribut aplicat la ele, a se vedea discuția mai detaliată a soluțiilor.
Codul generat de către anotator creează instanțe de wrapper-uri asupra atributelor interesante și le păstrează în câmpuri.\cite{converting_attributes_roslyn}


Urmează un exemplu al unui fișier generat.
Clasa \texttt{DummyDataObjectAnnotations} conține membrul \texttt{Text} cu codul sursă al fișierului, din care acest fișier a fost generat,
iar clasa \texttt{DataObjectSymbols} reprezintă acel boilerplate ce ține de wrapper-uri pentru atribute.

\begin{minted}{csharp}
namespace Kari.Plugins.DataObject
{
    using Kari.GeneratorCore.Workflow;
    using Kari.Utils;
    internal static class DummyDataObjectAnnotations
    {
        internal const string Text = @"namespace Kari.Plugins.DataObject
{
    using System;
    using System.Diagnostics;

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    [Conditional(""CodeGeneration"")]
    public class DataObjectAttribute : Attribute
    {
    }
}
";
    }
    internal static partial class DataObjectSymbols
    {
        internal static AttributeSymbolWrapper<DataObjectAttribute> DataObjectAttribute { get; private set; }

        internal static void Initialize(NamedLogger logger)
        {
            var compilation = MasterEnvironment.Instance.Compilation;
            DataObjectAttribute = new AttributeSymbolWrapper<DataObjectAttribute>(compilation, logger);
        }
    }
}
\end{minted}

\subsection{Modul de funcționare a plugin-urilor}

Fiecare plugin, după cum s-a menționat anterior, trebuie să definească câte o clasă publică de \emph{administrator}, cel puțin una, care să implementeze interfața \texttt{IAdministrator}.
De obicei, administratorii definesc un tablou de \emph{analizori} care conține câte un analizor pentru fiecare proiect.
Administratorii deleghează deciziile concrete referitor la analiza tipurilor și generarea codului pentru ele la analizorii aceștia.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_Flags_FlagsAdministrator}.

Aceasta este codul administratorului plugin-ului pentru generarea codului pentru enumuri flag.
După cum se poate vedea, se utilizează funcțiile statice ale clasei \texttt{AdministratorHelpers}.
Aceste funcții acomodează exact cazul acesta de utilizare: lucrul printr-un tablou de analizori, câte o instanță pentru fiecare proiect.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_Administrator_67_163}.

\begin{itemize}
  \item În metoda \texttt{Initialize\(\)} tabloul cu analizorii se umple, câte un analizor pentru fiecare proiect;
  \item În metoda \texttt{Collect\(\)}, lucrul de colectare a simbolurilor pur și simplu se deleghează la analizori;
  \item În metoda \texttt{Generate\(\)}, se realizează generarea codului, aparte pentru fiecare proiect.
  \item Metoda \texttt{GetAnnotations\(\)} returnează textul acelui fișier cu anotațiile.
\end{itemize}

A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_Flags_FlagsAnalyzer}.

În acest exemplu, se poate vedea ce de obicei se face în metoda \texttt{CollectSymbols} al fiecărui analizor.
În acest caz, sunt colectate unele informații despre toate simbolurile cu atributul \texttt{NiceFlags}.
\inputminted[firstline=159, lastline=170]{cs}{../Kari/source/Kari.Plugins/Flags/FlagsAnalyzer.cs}

Metoda \texttt{GenerateCode\(\)} folosește aceste date pentru a formata un șir cu codul boilerplate și scrie rezultatul într-un \texttt{CodeBuilder}.
Early exit-ul garantează că dacă nici un tip nu a fost anotat cu atributul \texttt{NiceFlags}, nimic nu va fi generat.


\subsection{Plugin-ul Flags}

Cu toate că plugin-ul pentru generarea codului pentru enumuri flag deja a fost menționat în lucrare de mai multe ori, merită a vedea întreaga imagine.
Deci, plugin-ul Flags este un plugin pentru generatorul de cod Kari care permite generarea metodelor utile pentru lucrul cu enumuri flag.
Acestea includ următoarele:

\begin{itemize}
  \item \texttt{Has} și \texttt{DoesNotHave} care verifică prezența unui flag sau a unei combinații de flaguri în valoarea dată;
  \item \texttt{HasEither} și \texttt{DoesNotHaveEither} care verifică intersecția a două seturi de flaguri;
  \item \texttt{WithSet} și \texttt{WithUnset} care setează sau șterge un flag sau o combinație de flaguri, returnând valoarea modificată;
  \item \texttt{Set} și \texttt{Unset} care funcționează ca \texttt{WithSet} și \texttt{WithUnset}, doar că modifică argumentul;
  \item \texttt{Set} cu un argument boolean, care setează sau șterge un flag sau o combinație de flaguri, indicat de valoarea acestui argument.
\end{itemize}

Pentru demonstrare, se va crea un proiect nou în care se va folosi generatorul de cod Kari cu acest plugin.
Acest proiect este un proiect console fără dependențe pe .NET 6.
Fișierul principal conține următorul cod sursă, foarte asemănător cu exemplul din capitolul 1:
A se vedea Anexa \ref{appendix:uni_thesis____examples_flags_Program}.


Înainte de compilare trebuie să se ruleze generatorul de cod.
Pentru aceasta se invocă Kari cu drumul la fișierul de configurare \texttt{kari.json} care conține drumul la \ac{DLL}-ul plugin-ului Flags.
Acesta poate fi dat lui Kari și direct, însă utilizarea unui fișier de configurare este mai comod.
\inputminted{bat}{../examples/flags/kari.bat}
\inputminted{js}{../examples/flags/kari.json}


Și codul generat:
\inputminted{cs}{../examples/flags/Generated/FlagsAnnotations.cs}
A se vedea Anexa \ref{appendix:uni_thesis____examples_flags_Generated_Flags}.

\subsection{Plugin-ul DataObject}

DataObject este un plugin pentru Kari care permite generarea codului pentru tipuri care conceptual doar conțin datele.
Codului generat va conține supraîncărcări triviale pentru operatorii de egalitate, supraîncărcarea metodei \texttt{Equals}, \texttt{GetHashCode}.

De fapt, aceasta a fost implementat în versiunele noi de C\#, anume C\# 9 și C\# 10 din {{.}NET} 5 și {{.}NET} 6 respectiv, în forma de \emph{records} și \emph{record structs}, însă acestea nu sunt accesibile în Unity.\cite{records_in_csharp}

Administratorul acestui plugin are aceeași structură ca și administratorul plugin-ului Flags:
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAdministrator}.

Informațiile colectate au mai multe lucruri, ca simbolul tipului, simbolurile pentru câmpuri instance, etc.
\inputminted[firstline=160, lastline=180]{cs}{../Kari/source/Kari.Plugins/DataObject/DataObjectAnalyzer.cs}

Metoda \texttt{CollectSymbols} tot așa colectează simbolurile necesare și le pune în aceste obiecte cu informații suplimentare extrase.
Se mai fac niște verificări pentru a avertiza utilizatorul despre problemele cu tipul: trebuie să nu fie static, trebuie să fie parțial, trebuie să aibă un modificator de acces.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAnalyzer_14_46}.

Metoda pentru generarea codului este puțin mai complicată decât cea a plugin-ului Flags, deoarece codul generat depinde de detaliile tipului mai mult.
De exemplu, dacă tipul este o clasă, atunci operatorul \texttt{==} trebuie să verifice cazul când unul sau ambele argumente sunt nule.
A se vedea Anexa \ref{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAnalyzer_48_157}.

Proiectul cu exemplul de utilizare are aceeași structură ca și proiectul pentru flaguri, doar că menționează plugin-ul \texttt{DataObject} în loc de \texttt{Flags}.
Codul programului:
A se vedea Anexa \ref{appendix:uni_thesis____examples_dataobject_Program}.

Și codul generat:
A se vedea Anexa \ref{appendix:uni_thesis____examples_dataobject_Generated_DataObjects}.
\inputminted{cs}{../examples/dataobject/Generated/DataObjectAnnotations.cs}

\subsection{Operațiile cu Kari ca parte de un instrument centralizat de dezvoltare}

În cadrul unui proiect al său, autorul a realizat un instrument în limbajul D care permite integrarea mai ușoară a lui Kari, fără a folosi fișiere de proiecte MSBuild.
Codul definește două comenzi — una compilează Kari în configurația dată, iar a doua îl execută pe Kari, construind drumurile la \ac{DLL}-urile plugin-urilor din denumirile lor.
A se vedea Anexa \ref{appendix:race____race_dev_cli_source_commands_setup}.

Restul configurației se ia din fișierul de configurație care se conține în mapa cu proiectul Unity al jocului:
\inputminted{js}{../race/game/kari.json}

Instrumentul poate fi invocat din linia de comandă.
Scriptul \texttt{setup.bat} arată compilarea instrumentului și invocarea comenzii setup.
\inputminted{bat}{../race/setup.bat}

Se admite că numele executabilului generat este \texttt{dev}.
Atunci, comanda de setup poate fi executată în felul următor:

\begin{minted}{text}
dev setup
\end{minted}

Aceasta ia ca argumentele și toate acele argumente definite în cod, deci este foarte ușor de configurat.
De exemplu, se poate face:

\begin{minted}{text}
dev setup -kariConfiguration Release
\end{minted}

Pașii de compilare și de executare a generatorului de cod pot fi realizați aparte.

\begin{minted}{text}
dev kari build -- arguments_to_dotnet_build
dev kari run -- arguments_to_kari
\end{minted}

Aceste comenzi definite într-un sistem centralizat sunt foarte utile în timpul dezvoltării, și pentru pipeline-uri \ac{CI/CD}.
Logica concretă a procesului de build poate fi delegată la acest program \texttt{dev} în loc de a defini toata complexitate de build asociată cu jocurile în scripturi shell.
Programul \texttt{dev} este scris în limbajul de programare D, deci este foarte ușor de programat și de configurat, permite modalitățile avansate de programare, poate accesa librăria standartă excelentă Phobos, și este mult mai comod, ușor de menținut și portabil, decât scripturi shell.
Un astfel de program poate ori să se integreze cu alte scripturi \ac{CI/CD}, ori să le înlocuiască complet.


\chapterConclusionSection{implementation_chapter_id}

În acest capitol s-au discutat detaliile referitor la implementarea sistemului: cum se configurează sistemul, cum el interacționează cu plugin-urile, cum codul sursă este citit și cum sunt scrise fișierele de ieșire.
În acest capitol nu s-a discutat logica generării codului, deoarece aceasta deja vine din plugin-uri concrete.

Este clar că nu sunt considerate dependențele între proiecte și orice schimbare forțează codul pentru fiecare proiect să fie regenerat.
Încă, dependențele de fiecare plugin din punct de vedere a tipurilor cu atribute specifice, sau a tipului de output (dependent de totul input, sau pentru un proiect aparte) nu au fost explorate.
Acestea pot fi folosite pentru a accelera generatorul de cod și mai departe, dar necesită și mai mult cod și timp pentru a le implementa.

S-a discutat structura internă a plugin-urilor, și s-a exemplificat modul de utilizare a generatorului de cod cu plugin-uri particulare.
S-a demonstrat cum generarea codului poate fi incorporată într-un instrument centralizat care poate fi utilizat pentru automatizarea proceselor de dezvoltare a unui sistem informatic.

\unnumberedChapter{Concluzii finale și recomandări}

În lucrarea aceasta s-a argumentat necesitatea unui generator de cod general, creată din cauza limitațiilor limbajului C\#, care este des folosit pentru dezvoltarea jocurilor, și s-a argumentat de ce soluțiile existente nu sunt practice.

După aceasta, s-au stabilit cerințele principale pentru generatorul de cod și s-a discutat arhitectura generală a sistemului.
S-a decis că o arhitectură băzată pe plugin-uri, unde orchestratorul dirijează o mulțime de plugin-uri, soluționează problema conform cerințelor.
S-a discutat și fluxul de lucru dorit, mai precis, faptul că va fi o aplicație din linia de comandă.

S-au discutat detaliile de implementare a generatorului de cod Kari: cum se configurează sistemul, cum el interacționează cu plugin-urile, cum codul sursă este citit și cum sunt scrise fișierele de ieșire.
Au fost date unele exemple de plugin-uri utilizate pentru generarea codului.
A fost demonstrată utilizarea generatorului de cod în două proiecte demonstrative, precum și în cadrul unui instrument centralizat în limbajul D, pe care autorul l-a utilizat în cadrul dezvoltării unui joc în Unity.

Au fost discutate și unele direcții potențiale de îmbunătățire a proiectului:

\begin{itemize}
  \item Divizarea lui Kari la mai multe etape, pentru a acomoda utilizarea generatorului de cod ca librărie, și pentru a putea testa fiecare etapă aparte;
  \item Profilarea mai sigură a codului legat cu sălvarea conținutului fișierelor generate, și simplificarea lui dacă codul curent nu aduce beneficii din punct de vedere a vitezei de execuție;
  \item Explorarea posibilității de a stabili și de a optimiza timpul de execuție pe baza dependențelor fiecărui plugin, adică ce tipuri sau ce fișiere contribuie la codul generat;
  \item Mai multe idei care nu au fost discutate în această lucrare.
\end{itemize}

Însă, Kari deja a fost folosit cu succes în dezvoltarea jocurilor, și instrumentul a ieșit foarte ușor de utilizat, deschizând posibilități mari din punct de vedere a complexității analizei codului și a codului generat.

\newpage
\markpage{usefulStuffEnd}

% Bibliography
\bibliographystyle{plain}
\bibliography{bibliography}
\addcontentsline{toc}{chapter}{\bibname}

%
\section*{Surse bibliografice proprii}

\begin{enumerate}
  \item Generator de cod: \url{https://github.com/AntonC9018/Kari}
  \item Proiectul de practică: \url{https://github.com/AntonC9018/race}
  \item Proiectul cu sursele tezei de licență: \url{https://github.com/AntonC9018/uni_thesis}
  \item Proiectul cu sursele tezei de an: \url{https://github.com/AntonC9018/Hopper_University_Paper}
  \item Proiectul tezei de an, include versiunea trecută a generatorului de cod: \url{https://github.com/AntonC9018/hopper.cs}
  \item Librăria folosită pentru argument parsing în D, scrisă parțial de către autorul tezei: https://github.com/BradleyChatha/JCLI
  \item Proiectele în care autorul a realizat puterea generării codului: \url{https://github.com/AntonC9018/opengl_experiments}, \url{https://github.com/AntonC9018/shader_descriptor}
  \item Realizarea puterei de metacompilare a limbajului D într-o aplicație grafică: \url{https://github.com/AntonC9018/shader_playground}
\end{enumerate}

% Appendices
\appendix
\setminted{%
  xleftmargin=0pt
}

% Number with arabic numbers instead of Roman
\renewcommand{\thechapter}{\arabic{chapter}}
% Prepend Anexa to section names, center them
\titleformat{\section}[block]{\normalfont\normalsize\bfseries\filcenter}{Anexa \thesection~}{0pt}{}

% Every section on new page
% \newcommand{\sectionbreak}{\clearpage}

% Since we've got just a single chapter in the appedices,
% but which is also the name of the Appendix chapter, it should be omitted.
% Makes little sense, but ok I guess.
\setcounter{chapter}{1}

\unnumberedChapter{Anexe}
\section{KariCompiler.cs}\label{appendix:Kari____Kari_source_Kari_Generator_KariCompiler}
\inputminted{cs}{../Kari/source/Kari.Generator/KariCompiler.cs}

\clearpage\section{ArgumentParsing.cs}\label{appendix:Kari____Kari_source_Kari_Arguments_ArgumentParsing}
\inputminted{cs}{../Kari/source/Kari.Arguments/ArgumentParsing.cs}

\clearpage\section{AdministratorFinder.cs}\label{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_AdministratorFinder}
\inputminted{cs}{../Kari/source/Kari.GeneratorCore/Workflow/AdministratorFinder.cs}

\clearpage\section{MasterEnvironment.cs, rândurile 285--598}\label{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_285_598}
\inputminted[firstline=285, lastline=598]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\clearpage\section{MasterEnvironment.cs, rândurile 604--664}\label{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_604_664}
\inputminted[firstline=604, lastline=664]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\clearpage\section{MasterEnvironment.cs, rândurile 666--697}\label{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_MasterEnvironment_666_697}
\inputminted[firstline=666, lastline=697]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/MasterEnvironment.cs}

\clearpage\section{CodeBuilder.cs, rândurile 19--184}\label{appendix:Kari____Kari_source_Kari_Utils_CodeBuilder_19_184}
\inputminted[firstline=19, lastline=184]{cs}{../Kari/source/Kari.Utils/CodeBuilder.cs}

\clearpage\section{Annotator.cs}\label{appendix:Kari____Kari_source_Kari_Annotator_Annotator}
\inputminted{cs}{../Kari/source/Kari.Annotator/Annotator.cs}

\clearpage\section{InternalPlugin.props}\label{appendix:Kari____Kari_source_Kari_Plugins_InternalPlugin}
\inputminted{xml}{../Kari/source/Kari.Plugins/InternalPlugin.props}

\clearpage\section{FlagsAdministrator.cs}\label{appendix:Kari____Kari_source_Kari_Plugins_Flags_FlagsAdministrator}
\inputminted{cs}{../Kari/source/Kari.Plugins/Flags/FlagsAdministrator.cs}

\clearpage\section{Administrator.cs, rândurile 67--163}\label{appendix:Kari____Kari_source_Kari_GeneratorCore_Workflow_Administrator_67_163}
\inputminted[firstline=67, lastline=163]{cs}{../Kari/source/Kari.GeneratorCore/Workflow/Administrator.cs}

\clearpage\section{FlagsAnalyzer.cs}\label{appendix:Kari____Kari_source_Kari_Plugins_Flags_FlagsAnalyzer}
\inputminted{cs}{../Kari/source/Kari.Plugins/Flags/FlagsAnalyzer.cs}

\clearpage\section{Program.cs}\label{appendix:uni_thesis____examples_flags_Program}
\inputminted{cs}{../examples/flags/Program.cs}

\clearpage\section{Flags.cs}\label{appendix:uni_thesis____examples_flags_Generated_Flags}
\inputminted{cs}{../examples/flags/Generated/Flags.cs}

\clearpage\section{DataObjectAdministrator.cs}\label{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAdministrator}
\inputminted{cs}{../Kari/source/Kari.Plugins/DataObject/DataObjectAdministrator.cs}

\clearpage\section{DataObjectAnalyzer.cs, rândurile 14--46}\label{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAnalyzer_14_46}
\inputminted[firstline=14, lastline=46]{cs}{../Kari/source/Kari.Plugins/DataObject/DataObjectAnalyzer.cs}

\clearpage\section{DataObjectAnalyzer.cs, rândurile 48--157}\label{appendix:Kari____Kari_source_Kari_Plugins_DataObject_DataObjectAnalyzer_48_157}
\inputminted[firstline=48, lastline=157]{cs}{../Kari/source/Kari.Plugins/DataObject/DataObjectAnalyzer.cs}

\clearpage\section{Program.cs}\label{appendix:uni_thesis____examples_dataobject_Program}
\inputminted{cs}{../examples/dataobject/Program.cs}

\clearpage\section{DataObjects.cs}\label{appendix:uni_thesis____examples_dataobject_Generated_DataObjects}
\inputminted{cs}{../examples/dataobject/Generated/DataObjects.cs}

\clearpage\section{setup.d}\label{appendix:race____race_dev_cli_source_commands_setup}
\inputminted{d}{../race/dev_cli/source/commands/setup.d}

\end{document}